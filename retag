#!/usr/bin/env python3
"""
Script to parse a "description" tag in a song, corresponding to the youtube version of the song, and parse it to produce
other tags. Existing tags are also used to produce new ones, e.g. moving strings like "2020 Remix" from the title tag to
the version tag.
"""

__author__ = "Simon Bengtsson"
__version__ = "0.1.0"
__license__ = "GPLv3"

from mutagen.oggopus import OggOpus  # type: ignore
from colorama import Fore, init  # type: ignore
from pathlib import Path
from simple_term_menu import TerminalMenu  # type: ignore

from cli import Cli
import colors
import constants

from description_parser import DescriptionParser
from music_tags import MusicTags
from tags_parser import TagsParser
from utils import Utils

init(autoreset=True)


def main(args):
    music_dir = Path(args.dir).resolve()
    all_files = list(filter(Path.is_file, Path(music_dir).glob('*.opus')))

    if args.manual_album is not None:
        constants.all_tags["discsubtitle"] = constants.all_tags["album"]
        constants.all_tags["discsubtitle"]["print"] = "Disc subtitle"
        constants.all_tags["album"]["pattern"] = []

    for idx, file_path in enumerate(all_files):
        redo = True
        file_name = Utils().file_path_to_song_data(file_path)
        while redo:
            redo = False
            # Print info about file and progress
            print(Fore.BLUE + f"\nSong {idx + 1} of {len(all_files)}")
            print(Fore.BLUE + f"----- File: {file_name} -----")

            # 1. Read the data and make basic improvements
            old_metadata: OggOpus = OggOpus(file_path)
            old_tags = {}
            tag_source = {}
            for key, val in old_metadata.items():
                old_tags[key] = val
            for key in old_tags.keys():
                tag_source[key] = colors.md_col
            tags = MusicTags()
            tags.set_original_tags(old_tags)
            prepare_resolved = old_tags.copy()
            tags.set_resolved_tags(prepare_resolved)
            old_tags_parser = TagsParser()
            old_tags_parser.parse_tags(tags.original)
            old_tags_parser.process_existing_tags()
            tags.set_tags_from_old_tags(old_tags_parser.get_tags())

            # 2. Get description
            description_lines: list[str] | None = old_metadata.get("synopsis")
            if description_lines is None:
                description_lines = old_metadata.get("description")

            # 3. If description exists, send it to be parsed
            if description_lines is not None:
                desc_parser = DescriptionParser()
                description = '\n'.join(description_lines)
                desc_parser.parse(description)
                tags.set_youtube_tags(desc_parser.get_tags())
                tags.add_source_tag()

                new_tags_parser = TagsParser()
                new_tags_parser.parse_tags(tags.youtube)
                tags.set_tags_from_description(new_tags_parser.get_tags())

            # 4. For each field, if there are conflicts, ask user input
            tags.adjust_metadata()

            # 4.5 Get rid of shady tags
            tags.prune_final_metadata()

            # 4.5.1 Manually set album
            if args.manual_album is not None:
                tags.resolved["album"] = [args.manual_album]

            # 5. Show user final result and ask if it should be saved or retried, or song skipped
            reshow_choices = True
            # if all(color == colors.md_col for color in tag_source.values()):
            #     if args.fix_descriptionless:
            #         reshow_choices = False if input("Only basic suggested, skip? (Y/n): ") == 'n' else True
            #     else:
            #         reshow_choices = False
            #       print(Fore.YELLOW + "No signficant changes suggested, therefore only auto-saving the basic changes")
            #     if not reshow_choices:
            #         old_metadata.save()
            #         print(Fore.YELLOW + f"Metadata saved for file: {file_name}")

            while reshow_choices:
                print("Final result:")
                tags.print_resolved()
                reshow_choices = False
                options = [
                        "[s] save",
                        "[r] reset",
                        "[m] modify field",
                        "[p] pass",
                        "[y] youtube description",
                        "[a] all metadata",
                        "[e] resolved metadata",
                        "[q] quit"
                        ]
                terminal_menu = TerminalMenu(options, title="What do you want to do?")
                choice = terminal_menu.show()
                print('-' * 40)

                action = "[q] quit"
                if choice is not None and not isinstance(choice, tuple):
                    action = options[choice]

                match action:
                    case "[q] quit":
                        print(Fore.YELLOW + "Skipping this and all later songs")
                        Utils().exit_now()
                    case "[s] save":
                        for tag, data in tags.resolved.items():
                            old_metadata[tag] = data
                        old_metadata.save()
                        print(Fore.GREEN + f"Metadata saved for file: {file_name}")
                    case "[r] reset":
                        print(f"Trying to improve metadata again for file: {file_name}")
                        redo = True
                    case "[m] modify field":
                        tags.modify_resolved_field()
                        print(Fore.BLUE + "Current metadata to save:")
                        tags.print_resolved()
                        reshow_choices = True
                    case "[p] pass":
                        print(Fore.YELLOW + f"Pass. Skipping song: {file_name}")
                    case "[y] youtube description":
                        if description_lines:
                            print(Fore.BLUE + "Original YouTube description:")
                            print(colors.yt_col + "\n".join(description_lines))
                        else:
                            print(Fore.RED + "No YouTube description tag for this song.")
                        reshow_choices = True
                    case "[a] all metadata":
                        print(Fore.BLUE + "All old and new metadata suggested for this file:")
                        tags.print_all()
                        reshow_choices = True
                    case "[e] resolved metadata":
                        print(Fore.BLUE + "Current metadata to save:")
                        tags.print_resolved()
                        reshow_choices = True
                    case _:
                        print(Fore.RED + "Something went wrong, starting over")
                        redo = True

            # At any step with user input, user can choose:
            # * Show conflicting fields
            # * Show fields that will be changed


if __name__ == "__main__":
    args = Cli.parse_arguments(__version__)
    main(args)
