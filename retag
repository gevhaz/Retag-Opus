#!/usr/bin/env python3
"""
Script to parse a "description" tag in a song, corresponding to the
youtube version of the song, and parse it to produce other tags.
"""

__author__ = "Simon Bengtsson"
__version__ = "0.1.0"
__license__ = "GPLv3"

import argparse
import re
import shtab

from mutagen.oggopus import OggOpus
from colorama import Fore, init
from pathlib import Path
from typing import Any, List, Dict, Optional, Tuple

INTERPUNCT = '\u00b7'
SPACE = '\u00b7'
SPACE = ' '
SEP = " | "
yt_col = Fore.MAGENTA
md_col = Fore.CYAN
man_col = Fore.GREEN
auto_col = Fore.YELLOW

init(autoreset=True)

all_tags: Dict[str, Dict[str, Any]] = {
    "title": {
        "print": "Title",
        "pattern": [
            r".*“(.*)” by .* from ‘.*’"
            ]
        },
    "album": {
        "print": "Album",
        "pattern": [
                r".*“.*” by .* from ‘(.*)’"
            ]
        },
    "albumartist": {
        "print": "Album Artist",
        "pattern": [
            ]
        },
    "artist": {
        "print": "Artist(s)",
        "pattern": [
            r"^(?!.*(https?|[mM]akeup|[fF]inishing)).*[aA]rtist.*:\s*(.+)\s*",
            r".*\([fF]eat. (.+?)\)",
            r".*“.*” by (.*) from ‘.*’"
            ]
        },
    "date": {
        "print": "Date",
        "pattern": [
                r"Released on:\s*(\d\d\d\d-\d\d-\d\d)"
            ]
        },
    "genre": {
        "print": "Genre",
        "pattern": [
            ]
        },
    "performer": {
        "print": "Performer",
        "pattern": [
            r".*[pP]erformer.*:\s*(.+)\s*"
            ]
        },
    "organization": {
        "print": "Organization",
        "pattern": [
            r"Provided to YouTube by (.+)\s*"
            ]
        },
    "copyright": {
        "print": "Copyright",
        "pattern": [
                r"\u2117 (.+)\s*"
            ]
        },
    "composer": {
        "print": "Composer",
        "pattern": [
            r".*?[cC]omposer.*:\s*(.+)\s*"
            ]
        },
    "conductor": {
        "print": "Conductor",
        "pattern": [
            r".*[cC]onductor.*:\s*(.+)\s*"
            ]
        },
    "arranger": {
        "print": "Arranger",
        "pattern": [
            r".*?[aA]rranged\s+[bB]y.*:\s*(.+)\s*",
            r".*?[aA]rranger.*:\s*(.+)\s*"
            ]
        },
    "author": {
        "print": "Author",
        "pattern": [
            r"(.*, )?[aA]uthor.*:\s*(.+)\s*"
            ]
        },
    "producer": {
        "print": "Producer",
        "pattern": [
            r"(.*, )?[pP]roducer.*:\s*(.+)\s*"
            ]
        },
    "publisher": {
        "print": "Publisher",
        "pattern": [
            r"(.*, )?[pP]ublisher.*:\s*(.+)\s*"
            ]
        },
    "lyricist": {
        "print": "Lyricist",
        "pattern": [
            r"(.*, )?[wW]riter.*:\s*(.+)\s*",
            r"(.*, )?[wW]ritten\s+[bB]y.*:\s*(.+)\s*",
            r".*[lL]yricist.*:\s*(.+)\s*"
            ]
        }
    }

performer_tags: Dict[str, Dict[str, Any]] = {
    "performer:vocals": {
        "print": "- Vocals",
        "pattern": [
            r"(.*, )?(Lead\s+)?[vV]ocal(?!.*[eE]ngineer).*:\s*(.+)\s*"
            ]
        },
    "performer:background vocals": {
        "print": "- Background Vocals",
        "pattern": [
            r"(.*, )?[bB]ackground\s+[vV]ocal.*:\s*(.+)\s*"
            ]
        },
    "performer:drums": {
        "print": "- Drums",
        "pattern": [
            r"(.*, )?[dD]rum.*:\s*(.+)\s*"
            ]
        },
    "performer:percussion": {
        "print": "- Percussion",
        "pattern": [
            r".*[pP]ercussion.*:\s*(.+)\s*"
            ]
        },
    "performer:keyboard": {
        "print": "- Keyboard",
        "pattern": [
            r"(.*, )?[kK]eyboard.*:\s*(.+)\s*"
            ]
        },
    "performer:piano": {
        "print": "- Piano",
        "pattern": [
            r"(.*, )?[pP]iano.*:\s*(.+)\s*"
            ]
        },
    "performer:synthesizer": {
        "print": "- Synthesizer",
        "pattern": [
            r".*[sS]ynth.*:\s*(.+)\s*"
            ]
        },
    "performer:guitar": {
        "print": "- Guitar",
        "pattern": [
            r"(.*, )?[gG]uitar.*:\s*(.+)\s*"
            r".*[eE]lectric\s+[gG]uitar.*:\s*(.+)\s*"
            ]
        },
    "performer:electric guitar": {
        "print": "- Electric guitar",
        "pattern": [
            ]
        },
    "performer:bass guitar": {
        "print": "- Bass guitar",
        "pattern": [
            r".*[bB]ass\s+[gG]uitar.*:\s*(.+)\s*"
            ]
        },
    "performer:acoustic guitar": {
        "print": "- Acoustic guitar",
        "pattern": [
            r".*[aA]coustic\s+[gG]uitar.*:\s*(.+)\s*"
            ]
        },
    "performer:ukulele": {
        "print": "- Ukulele",
        "pattern": [
            r".*[uU]kulele.*:\s*(.+)\s*"
            ]
        },
    "performer:violin": {
        "print": "- Violin",
        "pattern": [
            r"(.*, )?[vV]iolin.*:\s*(.+)\s*"
            ]
        },
    "performer:double bass": {
        "print": "- Double bass",
        "pattern": [
            r".*[dD]ouble\s+[bB]ass.*:\s*(.+)\s*"
            ]
        },
    "performer:cello": {
        "print": "- Cello",
        "pattern": [
            r"(.*, )?[cC]ello.*:\s*(.+)\s*"
            ]
        },
    "performer:programming": {
        "print": "- Programming",
        "pattern": [
            r"(.*, )?[pP]rogramm(er|ing).*:\s*(.+)\s*"
            ]
        },
    "performer:saxophone": {
        "print": "- Saxophone",
        "pattern": [
            r"(.*, )?[sS]axophone.*:\s*(.+)\s*"
            ]
        },
    "performer:flute": {
        "print": "- Flute",
        "pattern": [
            r"(.*, )?[fF]lute.*:\s*(.+)\s*"
            ]
        }
    }


def remove_duplicates(duplicates: list) -> list:
    return list(dict.fromkeys(duplicates))


def prune_title(original_title):
    pruned = re.sub(r"\([rR]emastered.*\)", "", original_title)
    pruned = re.sub(r"\s*\([fF]eat.*\)", "", pruned)
    return pruned.strip()


def split_tag(input: str) -> List[str]:
    return re.split(", | and |; ", input)


def parse_artist_and_title(source_line):
    artist_and_title = source_line.split(" " + INTERPUNCT + " ")
    title = prune_title(artist_and_title[0])
    artist: List = artist_and_title[1:]

    if len(artist) < 2 and ", " in artist[0]:
        artist = split_tag(artist[0])

    return artist, title


def parse(description_tag_full: str) -> Dict[str, List[str]]:
    new_metadata: Dict[str, List[str]] = {}
    lines_since_title_artist: int = 1000

    description_tag_lines: List[str] = description_tag_full.splitlines(False)

    def standard_pattern(field_name, regex):
        pattern = re.compile(regex)
        pattern_match = re.match(pattern, description_line)
        if pattern_match:
            field_value = pattern_match.groups()[len(pattern_match.groups())-1]
            field_value = field_value.strip()
            if new_metadata.get(field_name):
                new_metadata[field_name].append(field_value)
                new_metadata[field_name] = remove_duplicates(new_metadata[field_name])
            else:
                new_metadata[field_name] = [field_value]

    for description_line in description_tag_lines:
        description_line = description_line.replace('\n', '')
        description_line = re.sub('\n', '', description_line)
        lines_since_title_artist = lines_since_title_artist + 1
        # Artist and title
        if INTERPUNCT in description_line:
            lines_since_title_artist = 0
            youtube_artist, youtube_title = parse_artist_and_title(description_line)
            if youtube_artist:
                new_metadata["artist"] = remove_duplicates(youtube_artist)
            new_metadata["title"] = [youtube_title]

        if lines_since_title_artist == 2:
            new_metadata["album"] = [description_line.strip()]

        for tag_id, tag_data in all_tags.items():
            for pattern in tag_data['pattern']:
                standard_pattern(tag_id, pattern)

        for tag_id, tag_data in performer_tags.items():
            for pattern in tag_data['pattern']:
                standard_pattern(tag_id, pattern)

        title = new_metadata.pop("title", None)
        if title:
            new_metadata['title'] = [prune_title(title[0])]

    artist = new_metadata.get("artist")
    if artist:
        new_metadata["albumartist"] = [artist[0]]
        if len(artist) > 1:
            many_artist: List[str] = []
            for a in artist:
                many_artist = many_artist + split_tag(a)
            artist = many_artist
        else:
            artist = split_tag(artist[0])
        artist = remove_duplicates(artist)
        new_metadata['artist'] = artist

    for key, value in new_metadata.items():
        if value == []:
            new_metadata.pop(key)
    # Basic pattern:
    # r".*[ ]   .*:\s*(.*)\s*"

    standard_pattern("copyright_date", r"\u2117 (\d\d\d\d)\s")
    copyright_date = new_metadata.pop("copyright_date", None)
    date = new_metadata.get("date")
    if copyright_date and not date:
        new_metadata["date"] = copyright_date

    return new_metadata


def print_metadata_key(key_type, key, key_col, data):
    value = SEP.join(data.get(key, [Fore.BLACK + 'Not found'])).replace(' ', SPACE)
    print("  " + key_type + ": " + key_col + value)


def print_metadata(data, tag_source, default_col):
    if "performer:" in ' '.join(data.keys()):
        print("  Performers:")
        for tag_id, tag_data in performer_tags.items():
            if tag_id in data and data[tag_id] is not None:
                print_metadata_key(tag_data["print"], tag_id, tag_source.get(tag_id, default_col), data)
    for tag_id, tag_data in all_tags.items():
        print_metadata_key(tag_data["print"], tag_id, tag_source.get(tag_id, default_col), data)
    print("")


def adjust_metadata(new_metadata: Dict[str, List[str]],
                    old_metadata: OggOpus,
                    tag_source: Dict[str, str]) -> Tuple[OggOpus, Dict[str, str]]:

    # Date should be safe to get from description
    date = new_metadata.get("date", None)
    if date and date != old_metadata.get("date"):
        old_metadata["date"] = date
        tag_source["date"] = yt_col

    # youtube-dl is default album, auto-change
    md_album = old_metadata.get("album")
    yt_album = new_metadata.get("album")
    if yt_album and md_album == ["youtube-dl"]:
        old_metadata["album"] = yt_album
        tag_source["album"] = yt_col

    md_artist = old_metadata.get("artist")
    yt_artist = new_metadata.get("artist")
    if md_artist is not None and len(md_artist) == 1 and split_tag(md_artist[0]) == yt_artist:
        old_metadata["artist"] = yt_artist
        tag_source["artist"] = yt_col

    # Compare all fields
    for field, yt_value in new_metadata.items():
        old_value = old_metadata.get(field)
        if old_value is None and field != "albumartist":
            print(Fore.YELLOW + f"{field.title()}: No value exists in metadata. Using parsed data.")
            old_metadata[field] = yt_value
            tag_source[field] = yt_col
        elif yt_value == old_value:
            print(Fore.GREEN + f"{field.title()}: Metadata matches YouTube description.")
            tag_source[field] = md_col
        else:
            redo = True
            print("-----------------------------------------------")
            print_metadata(old_metadata, tag_source, Fore.RED)
            while redo:
                redo = False
                print(Fore.RED + f"{field.title()}: Mismatch between values in description and metadata:")
                print("  1. Exisiting metadata:  " + md_col + f"{' | '.join(old_metadata.get(field, ['Not set']))}")
                print("  2. YouTube description: " + yt_col + f"{' | '.join(yt_value)}")
                print("  3. Manually fill in tag")
                print("  4. Print description metadata")
                print("  5. Remove field")
                choice = input("Choose the number you want to use. Empty leaves metadata unchanged: ")
                if choice == '2':
                    old_metadata[field] = yt_value
                    tag_source[field] = yt_col
                elif choice == '3':
                    old_metadata[field] = [input("Value: ")]
                    tag_source[field] = man_col
                elif choice == '4':
                    print("-----------------------------------------------")
                    print_metadata(new_metadata, {}, yt_col)
                    redo = True
                elif choice == '5':
                    old_metadata.pop(field, None)
                    tag_source[field] = man_col
                else:
                    tag_source[field] = md_col

    return old_metadata, tag_source


def modify_field(old_metadata: OggOpus, tag_source: Dict[str, str]) -> Tuple[OggOpus, Dict[str, str]]:
    key = " "
    val = " "
    while key and val:
        print("Enter key and value (newline cancels):")
        key = input("  Key: ")
        val = input("  Value: ")
        if key and val:
            old_metadata[key] = [val]
            tag_source[key] = man_col
        else:
            break
    return old_metadata, tag_source


def adjust_existing_data(old_metadata: OggOpus, tag_source: Dict[str, str]) -> Tuple[OggOpus, Dict[str, str]]:
    old_metadata["comment"] = ["youtube-dl"]  # All youtube songs should have description tag

    old_metadata.pop("language", None)
    old_metadata.pop("compatible_brands", None)
    old_metadata.pop("minor_version", None)
    old_metadata.pop("major_brand", None)
    old_metadata.pop("vendor_id", None)

    # If the date is just the upload date, discard it
    if old_metadata.get("date") and re.match(r"\d\d\d\d\d\d\d\d", old_metadata["date"][0]):
        old_metadata.pop("date", None)

    old_title = old_metadata.get("title")
    if old_title:
        featuring_regex = r".*\([fF]eat. (.+?)\).*"
        pattern_match = re.match(featuring_regex, old_title[0])
        if pattern_match:
            new_artist = pattern_match.groups()[0].strip()
            old_artist = old_metadata.get('artist')

            if (old_artist and new_artist not in old_artist) or (old_artist is None and new_artist is not None):
                tag_source['artist'] = auto_col

            if old_artist and old_artist[0] != new_artist:
                old_artist.append(new_artist)
                old_metadata['artist'] = remove_duplicates(old_artist)
            else:
                old_metadata['artist'] = [new_artist]

            pruned_title = prune_title(old_title[0])
            if old_title != pruned_title:
                old_metadata["title"] = pruned_title
                tag_source["title"] = auto_col

    tags_to_split = ['genre', 'artist']

    old_title = old_metadata.get("title")

    for tag in tags_to_split:
        original_tag = old_metadata.get(tag)
        if original_tag is not None and not len(original_tag) > 1:
            new_tag = split_tag(original_tag[0])
            if new_tag != original_tag:
                old_metadata[tag] = new_tag
                tag_source[tag] = auto_col

    return old_metadata, tag_source


def get_basename(file_path: Path) -> str:
    file_name = str(file_path)
    basename = re.match(".*/(.*)", file_name)
    if basename:
        match = basename.groups()[0]
        file_name = match
        name_playlist = re.match("<(.*)> - <(.*)> - <(.*)> - <(.*)>.opus", file_name)
        name_single = re.match("<(.*)> - <(.*)>.opus", file_name)
        if name_playlist:
            file_name = name_playlist.groups()[1] + " - " + name_playlist.groups()[2]
        elif name_single:
            file_name = name_single.groups()[0] + " - " + name_single.groups()[1]

    return file_name


def main(args):
    music_dir = Path(args.dir).resolve()
    all_files = list(filter(Path.is_file, Path(music_dir).glob('*.opus')))

    for idx, file_path in enumerate(all_files):
        stop = False
        redo = True
        file_name = get_basename(file_path)
        while redo:
            redo = False
            # Print info about file and progress
            print(Fore.BLUE + f"\nSong {idx + 1} of {len(all_files)}")
            print(Fore.BLUE + f"----- File: {file_name} -----")

            # 1. Read the data and make basic improvements
            old_metadata: OggOpus = OggOpus(file_path)
            old_tags = {}
            tag_source = {}
            for key, val in old_metadata.items():
                old_tags[key] = val
            for key in old_tags.keys():
                tag_source[key] = md_col
            old_metadata, tag_source = adjust_existing_data(old_metadata, tag_source)

            # 2. Get description
            description_lines: List | None = old_metadata.get("synopsis")
            if description_lines is None:
                description_lines = old_metadata.get("description")

            # 3. If description exists, send it to be parsed
            new_metadata: Optional[Dict[str, List[str]]] = None
            if description_lines is not None:
                description = '\n'.join(description_lines)
                new_metadata = parse(description)

            # 4. For each field, if there are conflicts, ask user input
            if new_metadata:
                old_metadata, tag_source = adjust_metadata(new_metadata, old_metadata, tag_source)

            # 5. Show user final result and ask if it should be saved or retried, or song skipped
            reshow_choices = True
            print("Final result:")
            print_metadata(old_metadata, tag_source, Fore.RED)
            if all(color == md_col for color in tag_source.values()):
                if args.fix_descriptionless:
                    reshow_choices = False if input("Only basic suggested, skip? (Y/n): ") == 'n' else True
                else:
                    reshow_choices = False
                    print(Fore.YELLOW + "No signficant changes suggested, therefore only auto-saving the basic changes")
                if not reshow_choices:
                    old_metadata.save()
                    print(Fore.YELLOW + f"Metadata saved for file: {file_name}")

            while reshow_choices:
                reshow_choices = False
                action_prompt = ("Action: (s)ave, (r)eset, (m)odify field, (p)ass, "
                                 "(y)outube description, (o)ld metadata, (c)urrent metadata, (d)escription metadata, "
                                 "(a)bort: ")
                action = input(action_prompt)
                print('-' * (len(action_prompt) + 1))
                if action == 's':
                    old_metadata.save()
                    print(Fore.GREEN + f"Metadata saved for file: {file_name}")
                elif action == "r":
                    print(f"Trying to improve metadata again for file: {file_name}")
                    redo = True
                elif action == "m":
                    old_metadata, tag_source = modify_field(old_metadata, tag_source)
                    print(Fore.BLUE + "Current metadata to save:")
                    print_metadata(old_metadata, tag_source, Fore.RED)
                    reshow_choices = True
                elif action == "p":
                    print(Fore.YELLOW + f"Pass. Skipping song: {file_name}")
                elif action == "y":
                    if description_lines:
                        print(Fore.BLUE + "Original YouTube description:")
                        print(yt_col + "\n".join(description_lines))
                    else:
                        print(Fore.RED + "No YouTube description tag for this song.")
                    reshow_choices = True
                elif action == "o":
                    print(Fore.BLUE + "The original metadata for this file:")
                    print_metadata(old_tags, {}, md_col)
                    reshow_choices = True
                elif action == "c":
                    print(Fore.BLUE + "Current metadata to save:")
                    print_metadata(old_metadata, tag_source, Fore.RED)
                    reshow_choices = True
                elif action == "d":
                    if new_metadata:
                        print(Fore.BLUE + "Metadata parsed from YouTube description:")
                        print_metadata(new_metadata, {}, yt_col)
                    else:
                        print(Fore.RED + "This song has no YouTube description tag to parse metadata from.")
                    reshow_choices = True
                elif action == "a":
                    print(Fore.YELLOW + "Skipping this and all later songs")
                    stop = True
                else:
                    print(Fore.RED + "Invalid choice. Try again:")
                    reshow_choices = True

        if stop:
            break
            # At any step with user input, user can choose:
            # * Show conflicting fields
            # * Show fields that will be changed


if __name__ == "__main__":
    parser = argparse.ArgumentParser()

    shtab.add_argument_to(parser, ["-s", "--print-completion"])

    parser.add_argument("-a",
                        "--all",
                        action="store_true",
                        default=False,
                        dest="fix_descriptionless",
                        help="Even if there is no YouTube description, suggest improving existing tags")

    parser.add_argument("-d",
                        "--directory",
                        action="store",
                        dest="dir",
                        help="directory in which the files to be retagged are located").complete = shtab.DIRECTORY

    parser.add_argument("-V",
                        "--version",
                        action="version",
                        version="%(prog)s (version {version})".format(version=__version__))

    args = parser.parse_args()
    main(args)
