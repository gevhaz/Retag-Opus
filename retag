#!/usr/bin/env python3
"""
Script to parse a "description" tag in a song, corresponding to the youtube version of the song, and parse it to produce
other tags. Existing tags are also used to produce new ones, e.g. moving strings like "2020 Remix" from the title tag to
the version tag.
"""

__author__ = "Simon Bengtsson"
__version__ = "0.1.0"
__license__ = "GPLv3"

from mutagen.oggopus import OggOpus  # type: ignore
from colorama import Fore, init  # type: ignore
from pathlib import Path
from typing import List, Dict, Tuple

from cli import Cli
import colors

from description_parser import DescriptionParser
from music_tags import MusicTags
from tags_parser import TagsParser
from utils import Utils

init(autoreset=True)


def modify_field(old_metadata: OggOpus, tag_source: Dict[str, str]) -> Tuple[OggOpus, Dict[str, str]]:
    key = " "
    val = " "
    while key and val:
        print("Enter key and value (newline cancels):")
        key = input("  Key: ")
        val = input("  Value: ")
        if key and val:
            old_metadata[key] = [val]
            tag_source[key] = colors.man_col
        else:
            break
    return old_metadata, tag_source


def main(args):
    music_dir = Path(args.dir).resolve()
    all_files = list(filter(Path.is_file, Path(music_dir).glob('*.opus')))

    for idx, file_path in enumerate(all_files):
        stop = False
        redo = True
        file_name = Utils().file_path_to_song_data(file_path)
        while redo:
            redo = False
            # Print info about file and progress
            print(Fore.BLUE + f"\nSong {idx + 1} of {len(all_files)}")
            print(Fore.BLUE + f"----- File: {file_name} -----")

            # 1. Read the data and make basic improvements
            old_metadata: OggOpus = OggOpus(file_path)
            old_tags = {}
            tag_source = {}
            for key, val in old_metadata.items():
                old_tags[key] = val
            for key in old_tags.keys():
                tag_source[key] = colors.md_col
            tags = MusicTags()
            tags.set_original_tags(old_tags)
            prepare_resolved = old_tags.copy()
            tags.set_resolved_tags(prepare_resolved)
            old_tags_parser = TagsParser()
            old_tags_parser.parse_tags(tags.original)
            old_tags_parser.process_existing_tags()
            tags.set_tags_from_old_tags(old_tags_parser.get_tags())

            # 2. Get description
            description_lines: List | None = old_metadata.get("synopsis")
            if description_lines is None:
                description_lines = old_metadata.get("description")

            # 3. If description exists, send it to be parsed
            if description_lines is not None:
                desc_parser = DescriptionParser()
                description = '\n'.join(description_lines)
                desc_parser.parse(description)
                tags.set_youtube_tags(desc_parser.get_tags())
                tags.add_source_tag()

                new_tags_parser = TagsParser()
                new_tags_parser.parse_tags(tags.youtube)
                tags.set_tags_from_description(new_tags_parser.get_tags())

            # 4. For each field, if there are conflicts, ask user input
            if tags.youtube or tags.fromtags:
                tags.adjust_metadata()

            # 4.5 Get rid of shady tags
            tags.prune_final_metadata()

            # 5. Show user final result and ask if it should be saved or retried, or song skipped
            reshow_choices = True
            print("Final result:")
            tags.print_resolved()
            # if all(color == colors.md_col for color in tag_source.values()):
            #     if args.fix_descriptionless:
            #         reshow_choices = False if input("Only basic suggested, skip? (Y/n): ") == 'n' else True
            #     else:
            #         reshow_choices = False
            #       print(Fore.YELLOW + "No signficant changes suggested, therefore only auto-saving the basic changes")
            #     if not reshow_choices:
            #         old_metadata.save()
            #         print(Fore.YELLOW + f"Metadata saved for file: {file_name}")

            while reshow_choices:
                reshow_choices = False
                action_prompt = ("Action: (s)ave, (r)eset, (m)odify field, (p)ass, "
                                 "(y)outube description, (o)ld metadata, (c)urrent metadata, (d)escription metadata, "
                                 "(a)bort: ")
                action = input(action_prompt)
                print('-' * (len(action_prompt) + 1))
                if action == 's':
                    old_metadata.save()
                    print(Fore.GREEN + f"Metadata saved for file: {file_name}")
                elif action == "r":
                    print(f"Trying to improve metadata again for file: {file_name}")
                    redo = True
                elif action == "m":
                    old_metadata, tag_source = modify_field(old_metadata, tag_source)
                    print(Fore.BLUE + "Current metadata to save:")
                    tags.print_resolved()
                    reshow_choices = True
                elif action == "p":
                    print(Fore.YELLOW + f"Pass. Skipping song: {file_name}")
                elif action == "y":
                    if description_lines:
                        print(Fore.BLUE + "Original YouTube description:")
                        print(colors.yt_col + "\n".join(description_lines))
                    else:
                        print(Fore.RED + "No YouTube description tag for this song.")
                    reshow_choices = True
                elif action == "o":
                    print(Fore.BLUE + "The original metadata for this file:")
                    tags.print_original()
                    reshow_choices = True
                elif action == "c":
                    print(Fore.BLUE + "Current metadata to save:")
                    tags.print_resolved()
                    reshow_choices = True
                elif action == "d":
                    if tags.youtube:
                        print(Fore.BLUE + "Metadata parsed from YouTube description:")
                        tags.print_youtube()
                    else:
                        print(Fore.RED + "This song has no YouTube description tag to parse metadata from.")
                    reshow_choices = True
                elif action == "a":
                    print(Fore.YELLOW + "Skipping this and all later songs")
                    stop = True
                else:
                    print(Fore.RED + "Invalid choice. Try again:")
                    reshow_choices = True

        if stop:
            break
            # At any step with user input, user can choose:
            # * Show conflicting fields
            # * Show fields that will be changed


if __name__ == "__main__":
    args = Cli.parse_arguments(__version__)
    main(args)
